---
layout: post
title: C++基础知识(三)
description: 为学习清华大学数据机构,恶补C++语法.jpg
tag: 编程语言
---

## 第六章
    函数就是命名了的代码块

### 函数基础
一个典型的函数(function)定义包括以下部分: 返回类型(return type)、函数名字、由0个或
多个形参组成的列表以及函数体.

函数的调用完成两项工作:
1.用实参初始化函数对应的形参

2.将控制权转移给被调用函数

执行函数的第一步是(隐式地)定义并初始化它的形参(实参的类型必须与对应的形参类型匹配)

函数有几个形参,我们就必须提供相同数量的实参.

函数的形参列表可以为空,但是不能省略.最常用的定义一个不带形参的函数的办法是书写一个
空的形参列表. 不过为了与C语言兼容, 也可以使用关键字void表示函数没有形参:
```
// 隐式地定义空形参列表
void f1() { /*...*/ }
// 显式地定义空形参列表
void f2(void) { /*...*/ }
```

大多数类型都能用作函数的返回类型. 一种特殊的返回类型是void, 它表示函数不返回任何值

*局部对象*
在C++中, 对象有生命周期(对象的生命周期是程序执行过程中该对象存在的一段时间)

在所有函数体之外定义的对象存在于程序的整个执行过程中, 此类对象在程序启动时被创建, 直到
程序结束才会销毁. 局部变量的生命周期依赖于定义的方式

*自动对象*
我们把只存在于块执行期间的对象称为自动对象(automatic object), 形参是一种自动
对象, 函数开始时为形参申请存储空间, 因为形参定义在函数体作用域之内, 所以一旦函
数终止, 形参也就被销毁.

*局部静态对象*
某些时候, 我们需要令局部变量的生命周期贯穿函数调用及之后的时间, 可以将局部变量定义成
static类型从而获得这样的对象。

局部静态对象在程序的执行路径第一次经过对象定义语句时初始化, 并且知道程序终止才被销毁,
在此期间即使对象所在的函数结束执行也不会对它有影响.

*函数声明*
函数声明也称作函数原型. 函数的声明和函数的定义非常类似, 唯一的区别是函数声明无须函数体,
用一个分号替代即可.

函数的三要素描述了函数的接口, 说明了调用该函数所需的全部信息.

建议将函数声明放在头文件中,另外定义函数的源文件应该把含有函数声明的头文件包含进来

*分离式编译*
随着程序越来越复杂,我们希望把程序的各个部分分别储存在不同的文件中.

为了允许编写程序时按照逻辑关系将其划分开来, C++语言支持所谓的分离式编译, 分离式
编译允许我们把程序分割到几个文件中, 每个文件独立编译.

*编译和链接多个源文件*
TODO: 待进一步补充

### 参数传递

当形参是引用类型时, 我们说它对应的实参被引用传递或者函数被传引用调用.(引用形参
  是它对应的实参的别名)

当实参的值被拷贝给形参时, 形参和实参是两个相互独立的对象. 我们说这样的实参被值
传递或者函数被传值调用.

*传值参数*
```
int n = 0; // int类型的初始变量
int i = n; // i是n的值的副本
i = 42;    // i的值改变, n的值不变

// 关于指针形参
int n = 0, i = 42;
int *p = &n, *q = &i; // p指向n,q指向i
*p = 42;              // n的值改变, p不变
p = q;                // p现在指向了i; 但是i和n的值都不变
```
由上代码可知,当初始化一个非引用类型的变量时, 初始值被拷贝给变量

*传引用参数*

通过前面对引用的学习我们知道, 对引用的操作实际上是作用在引用所引的对象上.

引用形参与之类似, 通过使用引用形参, 允许函数改变一个或多个实参的值

*使用引用避免拷贝*

当某种类型不支持拷贝操作或拷贝大的类类型对象较为低效时, 函数只能通过引用形参访问
该类型的对象.

NOTE: 如果函数无须改变引用形参的值, 最好将其声明为常量引用

*使用引用形参返回额外信息*

一个函数只能返回一个值, 然而有时函数需要同时返回多个值, 引用形参可以帮助我们满足这个需求

```
\\ 定义find_char函数, 返回在string对象中某个指定字符第一次出现的位置和该字符出现的总次数
string::size_type find_char(const string &s, char c, string::size_type &occurs)
{
  auto ret = s.size();    // 定义第一次出现的位置并初始化
  occurs = 0;             // 设置表示出现次数的形参的值
  for (decltype(ret) i = 0; i != s.size(); ++i){
    if(s[i] == c) {
      if(ret == s.size()){ret = i;}
      ++occurs;
    }
  }
  return ret;
}

\\ 当我们调用find_char函数时, 传入实参： 作为查找范围的string对象;要找的字符以及一个
用于保存字符出现次数的size_type对象
```

*const形参和实参*
TODO: 待重新看一遍

*指针或引用形参与const*
TODO: 待重新看一遍

*尽量使用常量引用*
TODO: 待重新看一遍

### 数组形参

由于数组本身的特性, 所以当我们为函数传递一个数组时, 实际上传递的是指向数组首元素的指针.

```
void print(const int*);
void print(const int[]);  // 可以看出来,函数的意图是作用于一个数组
void print(const int[10]);// 这里的维度表示我们期望数组含有多少个元素

// 上面三种表达方式等价, 每个函数的唯一形参都是const int*
```

如何管理指针形参:
1.使用标记制定数组长度[要求数组本身包含一个结束标记]

此方法的典型实例是C风格字符串,C风格字符串储存在字符数组中, 并且在最后一个字符后面跟着
一个空字符

2.使用标准库规范
```
void print(const int *beg, const int *end){
  // 输出beg到end之间的所有元素
  while(beg != end)
    cout << *beg++ << endl;
}
```

3.显式传递一个表示数组大小的形参
```
void print(const int ia[], size_t size){

}
```

4.数组引用形参

C++允许变量定义成数组的引用, 基于同样的道理, 形参也可以是数组的引用, 即void print(int (&arr)[10]){}

但此处的定义限制了print喊得可用性, 我们只能将函数作用域大小为10的数组

*传递多维数组*
```
void print(int (*matrix)[10], int rowSize) { }

void print(int matrix[][10], int rowSize) { }
```

### 含有可变形参的函数

为了编写能处理不同数量实参的函数, C++11新标准提供了两种主要的方法:

如果所有的实参类型相同, 可以传递一个名为initializer_list的标准库类型; 如果实参的
类型不同, 我们可以编写一种特殊的函数, 即所谓的可变参数模板。

initializer_list是一种标准库类型, 用于表示某种特定类型的值的数组

含有initializer_list形参的函数也可以同时拥有其他形参

示例:
```
void error_msg(ErrCode e, initializer_list<string> i1){
  cout << e.msg() << ":";
  for (const auto &elem : i1)
    cout << elem << " ";
  cout << endl;
}
```

*省略符形参*
省略符形参是为了便于C++程序访问某些特殊的C代码而设置的,这些代码使用了名为varargs的C标准库
功能, 通常, 省略符形参不应用于其他目的. [另外, 省略符形参只能出现在形参列表的最后一个位置]

## 返回类型和return语句

return语句终止当前正在执行的函数并将控制权返回到调用该函数的地方

*无返回值的函数*

没有返回值的return语句只能用在返回类型是void的函数中.

返回void的函数不要求非得有return语句, 因为在这类函数的最后一句后面会隐式地执行return

*有返回值的函数*

只要函数的返回类型不是void, 则该函数内的每条return语句必须返回一个值.

return语句返回值的类型必须与函数的返回类型相同.

在含有return语句的循环后面应该也有一条return语句用以考虑循环中未执行return语句的情况.

*值是如何被返回的*

*不要返回局部对象的引用或指针*

*返回类类型的函数和调用运算符*

*列表初始化返回值*
