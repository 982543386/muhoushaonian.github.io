---
layout: post
title: 清华大学-邓俊辉MOOC数据结构与算法学习笔记(二)
description: 老师感觉很有意思，继续往下学
tag: 数据结构
---

### 01-D-1 算法分析

DSA - DATA Structures and ALgorithms

算法分析:

  两个主要任务 = 正确性(不变性 * 单调性) + 复杂度

  C++等高级语言的基本指令，均等效于常数条RAM的基本指令;在渐进意义下，二者基本相当

复杂度分析的主要方法:

  迭代:级数求和

  递归:递推跟踪 + 递推方程

  猜测+验证

### 01-D-2 级数

算数级数: 与末项平方同阶
    T(n) = 1+2+...+n = n(n+1)/2 = O(n^2)

幂方级数: 比幂次高出一阶

    Eg: 1^2+2^2+3^2+4^2+...=O(n^3)

几何级数: 与末项同阶

    Eg: 1+2+4+...+2^n=O(2^n)

收敛级数

    1/1/2 + 1/2/3 + 1/3/4 + ... +1/(n-1)/n = 1- 1/n = O(1)

    1 + 1/2^2 + ... + 1/n^2 = O(1)

    1/3 + 1/7 + 1/8 + 1/15 + 1/24 + 1/26 + 1/31 + 1/35 + ... = 1 =O(1)

    h(n) = 1 + 1/2 + 1/3 + ... + 1/n = O(logn) // 调和级数

    log1 + log2 + log3 + ... + logn = O(nlogn) // 对数级数

对更多级数感兴趣的，不妨阅读: Concrete Mathematics //ex-2.35 Goldbach Theorem

### 01-D-3 级数与循环

```
for(int i = 0; i<n; i++)
for(int j = 0; j<n; j++)
  01Operation(i,j);
```
上述代码时间复杂度 T(n)=n+n+n+n+...+n=n*n=O(n^2)

```
for(int i = 0;i<n; i++)
for(int j = 0;j<i; j++)
  01Operation(i,j)
```
上述代码时间复杂度 T(n)=0+1+...(n-1)=O(n^2)

特别有意思的点在于邓老师利用平面直角坐标系进行表达:
![](/images/post_image/循环复杂度分析.png)

```
for(int i = 0; i<n; i++)
for(int j = 0; j<i; j += 2013) // +=运算符: b+=c 即b=b+c
  01Operation(i,j);
```
此部分代码的时间复杂度在于步长j的步长被改变，可以理解为三角形的一边被缩短

```
for(int i = 1; i<n; i<<=1)
for(int j = 0; j<i; j++)
  01Operation(i,j);
```
外循环变量i左移(即翻两倍)，即i成指数级增长

Eg: 当n为128时，i值变更7次

几何级数: 1 + 2 + 4 + ... + 2^[log_2(n-1)]=O(n)  

分析: 这里如何列出该几何级数？


### 01-D-4+5 取非极端元素、冒泡排序及其分析

**取非极端元素**

问题: 给定整数子集S， |S| = n >= 3，找出元素a属于S，a不等于max(S),且a不等于min(S)

算法: 从S中任取三个元素{x ,y ,z),确定并排除其中的最小、最大值，输出剩下的元素z

补充:
a. S以数组形式给出，不妨取前三个(实际上S元素选取任意),又由于S是几何，这三个元素必互异

b. 无论输入规模n多大，该算法所需要的执行时间都不变 T(n)=O(1)

**起泡排序**

问题: 给定n个整数，将它们按序排列

分析: 有序序列的特点: 任意一对相邻元素顺序 无序序列: 总有一对相邻元素乱序

算法: 依次比较每一对相邻元素，如有必要，交换之；若整趟扫描都没有进行交换，则排序完成；
否则，再做一趟扫描交换[不断改善局部的有序性实现整体的有序]

值得注意的是经过一次扫描交换，序列未必达到整体有序[可以自己在草稿纸上自己人肉跑序列]
![](/images/post_image/起泡排序.png)
```
void bubblesort(int A[], int n){ // 起泡排序算法(version1A)
  bool sorted = false; // 整体排序标志，首先假定尚未排序
  while(!sorted){ // 在尚未确认已全局排序之前，逐趟进行扫描交换
    sorted = true; // 假定已排序完成
    for(int i=1; i<n; i++){ //自左向右逐对检查当前范围A[0,n)内的各相邻元素
      if(A[i-1] > A[i]){ //一旦A[i-1]与A[i]逆序，则
        swap(A[i-1],A[i]); //交换之
        sorted = false; //因整体排序不能保证，需要清除排序标志
      }
    }
    n--; //至此最后一个元素[即最大的元素]必然沉底，故可以缩短待排序序列的长度
  }
} //借助sorted，可及时提前退出[即若整趟·扫描都没有进行交换，则排序完成]

```

起泡排序的特点:
a. 不变性[经k轮扫描交换后，最大的k个元素必然就位]

b. 单调性[经k轮扫描贾环后，问题规模缩减至(n-k)]

c. 正确性[经至多n趟扫描后，算法必然终止，且能给出正确解答]

起泡排序的复杂度T(n)=O(n^2)
