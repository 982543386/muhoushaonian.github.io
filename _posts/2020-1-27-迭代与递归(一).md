---
layout: post
title: 迭代与递归(一)
description: Nope
tag: 数据结构
---

### 01-D-6/7 封底估算及其实例

封底估算(Back-of-The-Envelope Calculation)

我们常用的大O法定性的分析了一个算法的时间复杂度

而封底估算则是用头脑去抓住问题的主要方面，尽快的得出一个问题的足够近似的估计

Eg:

n = 10^9[假定当前人口数为10亿],
我们考察对全国人口普查数据的排序

![](/images/post_image/封底估算.png)

从上图中我们可以看出硬件和软件分别对该问题排序效率改进的影响,也可以意识到算法研究对实际问题的重要性

[这里可以跑个题，刚刚在微信群里看到当前防疫有调度优化算法的需求，可见算法可以在不同时刻发挥自己特有的威力]

### 01-E-1 迭代和递归

    迭代乃人工，递归方神通
    To iterate is human, to recurse, divine

*哈哈哈哈哈哈哈，这句话真是直接戳中笑点*

  递归的价值在于，许多应用问题都可简洁而准确地描述为递归形式。

设计高效DSA思想之一: 分而治之[divide and conquer]

Eg:
问题: 计算任意n个整数的和

```
int SumI(int A[], int n){
  int sum = 0; //O(1)
  for(int i = 0; i<n; i++) //O(n)
    sum += A[i]; //O(1)
  return sum;
}
```
就该特定问题而言，T(n)=1+n+1=n+2= O(n)

我们用线性递归来理解该数组求和问题

```
int sum(int A[], int n){ //数组求和算法(线性递归版)
  if(n < 1) //平凡情况，递归基
    return 0; //直接计算(避免无限递归)
  else //一般情况
    return sum(A, n - 1) + A[n - 1]; //递归:前n-1项之和，再累计最后一个项
} //O(1)*递归深度 = O(1)*(n+1) = O(n)
```

通过这个实例来理解线性递归:算法sum()可能朝着更深一层进行自我调用，且每一递归实例对自身的调用至多一次，于是，每一层次至多只有一个实例，且它们构成一个线性的次序关系。

*递归基*:将一个规模为n的大问题退化为一个规模为n-1的小问题，直至退化为规模为1的平凡情况，该平凡情况即为递归基.(base case of recursion)

### 01-E-2 减而治之
Decrease-and-conquer

![](/images/post_image/减而治之.png)

为求解一个大规模的问题，可以将其划分为两个子问题:

其一平凡;另一规模缩减，最后将缩减为一平凡的问题

### 01-E-3 递归跟踪 递推方程

**递归跟踪(recursion trace)**，具体而言，就是按照以下原则，将递归算法的执行过程整理为图的形式;

整理成图的形式所遵循的法则:
a. 算法的每一递归实例都表示为一个方框，其中注明了该实例调用的参数.

b. 若实例M调用实例N，则在M与N对应的方框之间添加一条有向联线.

![](/images/post_image/递归调用.png)

注: 向下的箭头表示递归调用，返回的箭头即表示返回值

我们从递归跟踪的角度来分析上述递归问题的时间复杂度:
从图中可以看出，该问题所需的计算时间=所有递归实例的创建、执行和销毁所需的时间总和，由于递归实例的创建和销毁均由操作系统负责完成，其对应的时间成本通常可近似为常数，如此而来，我们只需计算各递归实例中非递归调用部分所需的时间.

就上述具体问题而言，每一递归实例中需考虑 *判断n是否为0* , *累加* , *返回值* 三个元素，且每个递归实例中该三项元素至多执行一次。对于长度为n的数组，递归深度应为(n+1)

则整个算法时间复杂度T(n)=(n+1) * O(3) = O(n)

**递归方程**: 与递归跟踪分析相反，该方法无需给出具体的调用过程，而是通过对递归模式的数学归纳，导出复杂度定界函数的递推方程及其边界条件，从而将复杂度的分析，转化为递归方程的求解。

Eg: 以线性递归版sum()算法为例，将该算法处理长度为n的数组所需的时间成本记作T(n): 则为解决问题sum(A,n).需递归地解决问题sum(A,n-1),然后累加上A[n-1]

则用算式可以表示为: T(n) = T(n-1) + O(1) = T(n-1)+c
T(0)=d,用数学方法我们可以很轻易的得到T(n)=cn+d

### 01-E-4 数组倒置

Eg: 任给数组A[0,n),将其前后颠倒
如输入A[] = {3,1,4,1,5,9,2,6}，则输出A[]={6,2,9,5,1,4,1,3}

首先我们用线性递归来解决该问题

思路: 递归的关键在于通过归纳问题缩小问题的规模，在本问题中，为得到整个数组的倒置，可以先对换其首、末元素，然后递归地倒置除去首末元素后的数组.

```
void reverse(int* A,int lo,int hi){
  if(lo < hi){
    swap(A[lo], A[hi]); //交换数组首末元素
    reverse(A, lo+1,hi_1); //递归调用reverse
  } //else隐含了两种递归基(由输入数组的奇偶性带来)
}
```
分而治之

**实现递归**: 在设计递归算法时，往往需要多个角度反复尝试，方能确定对问题的输入及其规模的最佳划分方式。有时，还可能需要从不同的角度重新定义和描述原问题，使得经分解所得的子问题与原问题具有相同的语义形式


**多向递归**: 通过不同归纳问题的方式我们可以发现递归调用可能有多重可供选择的分支。

Eg: 前述计算幂函数power(2,n) = 2^n,我们可以重新定义和表述为
![](/images/post_image/幂函数的多向递归.png)

这样即可通过反复的平方运算和加倍运算得到power2(n)

代码实现:
```
__int64 power2(int n){ //优化递归版幂函数2^n算法
  if(n == 0) return 1;
  return (n & 1) ? sqr(power2(n >> 1)) << 1 : sqr(power2(n >> 1)); //根据奇偶性从二进制层面进行操作,老师真厉害.jpg
}
```

多向递归的思想也可以通过图片的形式形象的表达出来:
![](/images/post_image/分而治之.png)


### 补充 尾递归

在线性递归算法中，若递归调用在递归实例中恰好以最后一步操作的形式出现，则称为尾递归。
严格地说，只有当该算法(除平凡递归基外)任一实例都终止于这一递归调用时，才属于尾递归。
=


### 01-E-6 数组求和与二分递归

按照前述分而治之的思想我们来再次解决数组求和问题.

基本思路: 以居中的元素为界将数组一分为二;递归的对子数组分别求和;最后,子数组之和相加即为原数组的综合.

```
int sum(int A[],int lo,int hi){ //二分递归版数组求和
  if(lo == hi) //如遇递归基
    return A[lo] //直接返回该元素为最终求和结果
  else{ //否则(即数组中不止一个元素),则
    int mi=(lo + hi) >> 1; //以居中单元为界，将原区间一分为二
    return sum(A,lo,mi) + sum(A,mi+1,hi); //递归对各子数组求和,最后累加
  }
}
```

分析该算法的复杂度,为简便分析,我们考察n(8) = 2^m(3)形式的长度的数组的具体调用情况
,利用递归跟踪对其进行分析:

![](/images/post_image/数组求和递归跟踪.png)

从上图可以看出,算法启动后经m = log<sub>2</sub>n次递归调用达到递归基。

时间复杂度可以通过递推方程得出为O(n)

*鉴于每个递归实例仅需常数空间，故该算法仅需O(m+1) = O(logn)的附加空间*
[这里理解不太够]

Eg:
问题: 从数组区间A[lo,hi)中找出最大的两个整数A[x1]和A[x2]元素比较的次数，要求尽可能少
(A[x1] >= A[x2])

一般思路——循环扫描
```
void max2(int A[],int lo, int hi, int& x1, int& x2){//此处int&是C++对C的一个补充
  for(x1 = lo, int i = lo + 1 ; i < hi; i++) //扫描A[lo,hi),找出A[x1]
    if(A[x1] < A[i]) x1 = i; //永远使A[x1]指向最大
  for(x2 = lo, int i = lo + 1 ; i < x1; i++) //扫描A[lo,x1)
    if(A[x2] < A[i]) x2 = i; //
  for(int i = x1 + 1; i < hi; i++) //再扫描A(x1,hi)
    if(A[x2] < A[i]) x2 = i; //
}
```
该算法的比较次数为 n-1 + n-2 = 2n-3

改进思路1——合并循环
```
void max2(int A[],int lo, int hi, int& x1, int& x2){ //改进思路,有点像过五关斩六将
  if(A[x1 = lo] < A[x2 = lo+1]) swap(x1,x2);
  for(int i = lo+2; i<hi; i++) //这个循环加的贼有意思,直接三个循环变成一个循环
    if(A[x2] < A[i])
      if(A[x1] < A[x2 = i])
        swap(x1,x2);
}
```
最好情况比较次数: 1+(n-2)* 1=n-1
最坏情况比较次数: 1+(n-2)* 2=2n-3

改进思路2——分而治之
老师展示的思路图:
![](/images/post_image/分而治之解最大次大.png)

```
void max2(int A[],int lo, int hi, int& x1, int& x2){
  if(lo + 2 == hi){ //数组仅有两个元素
    if(A[x1 = lo] < A[x2 = lo+1]) swap(x1,x2);
  return;
  }
  if(lo + 3 == hi){ //数组仅有三个元素
    if(A[x1 = lo] < A[x2 = lo+1]) swap(x1,x2);
    if(A[x2]<A[lo+2])
      if(A[x1]<A[x2=lo+2])
        swap(x1,x2);
    return
  }
  int mi =(lo+hi)/2; //divide
  int x1L,x2L; max2(A,lo,mi,x1L,x2L);
  int x1R,X2R; max2(A,mi,hi,x1R,x2R);
  if(A[x1L] > A[x1R]){
    x1=x1L;x2=(A[x2L] > A[x1R]) ? x2L:x1R;
  }
  else{
    x1=x1R; x2 = (A[x1L] > A[x2R]) ? x1L:x2R;
  }
}
```

该思路的比较次数可通过递推方程求解:
T(n) = 2*T(n/2)+2 <= 5n/3-2
