---
layout: post
title: 清华大学-邓俊辉MOOC数据结构与算法学习笔记(四)
description: Nope
tag: 数据结构
---

### 补充 尾递归

在线性递归算法中，若递归调用在递归实例中恰好以最后一步操作的形式出现，则称为尾递归。
严格地说，只有当该算法(除平凡递归基外)任一实例都终止于这一递归调用时，才属于尾递归。
=


### 01-E-6 数组求和与二分递归

按照前述分而治之的思想我们来再次解决数组求和问题.

基本思路: 以居中的元素为界将数组一分为二;递归的对子数组分别求和;最后,子数组之和相加即为原数组的综合.

```
int sum(int A[],int lo,int hi){ //二分递归版数组求和
  if(lo == hi) //如遇递归基
    return A[lo] //直接返回该元素为最终求和结果
  else{ //否则(即数组中不止一个元素),则
    int mi=(lo + hi) >> 1; //以居中单元为界，将原区间一分为二
    return sum(A,lo,mi) + sum(A,mi+1,hi); //递归对各子数组求和,最后累加
  }
}
```

分析该算法的复杂度,为简便分析,我们考察n(8) = 2^m(3)形式的长度的数组的具体调用情况
,利用递归跟踪对其进行分析:

![](/images/post_image/数组求和递归跟踪.png)

从上图可以看出,算法启动后经m = log<sub>2</sub>n次递归调用达到递归基。

时间复杂度可以通过递推方程得出为O(n)

*鉴于每个递归实例仅需常数空间，故该算法仅需O(m+1) = O(logn)的附加空间*
[这里理解不太够]

Eg:
问题: 从数组区间A[lo,hi)中找出最大的两个整数A[x1]和A[x2]元素比较的次数，要求尽可能少
(A[x1] >= A[x2])

一般思路——循环扫描
```
void max2(int A[],int lo, int hi, int& x1, int& x2){//此处int&是C++对C的一个补充
  for(x1 = lo, int i = lo + 1 ; i < hi; i++) //扫描A[lo,hi),找出A[x1]
    if(A[x1] < A[i]) x1 = i; //永远使A[x1]指向最大
  for(x2 = lo, int i = lo + 1 ; i < x1; i++) //扫描A[lo,x1)
    if(A[x2] < A[i]) x2 = i; //
  for(int i = x1 + 1; i < hi; i++) //再扫描A(x1,hi)
    if(A[x2] < A[i]) x2 = i; //
}
```
该算法的比较次数为 n-1 + n-2 = 2n-3

改进思路1——合并循环
```
void max2(int A[],int lo, int hi, int& x1, int& x2){ //改进思路,有点像过五关斩六将
  if(A[x1 = lo] < A[x2 = lo+1]) swap(x1,x2);
  for(int i = lo+2; i<hi; i++) //这个循环加的贼有意思,直接三个循环变成一个循环
    if(A[x2] < A[i])
      if(A[x1] < A[x2 = i])
        swap(x1,x2);
}
```
最好情况比较次数: 1+(n-2)* 1=n-1
最坏情况比较次数: 1+(n-2)* 2=2n-3

改进思路2——分而治之
老师展示的思路图:
![](/images/post_image/分而治之解最大次大.png)

```
void max2(int A[],int lo, int hi, int& x1, int& x2){
  if(lo + 2 == hi){ //数组仅有两个元素
    if(A[x1 = lo] < A[x2 = lo+1]) swap(x1,x2);
  return;
  }
  if(lo + 3 == hi){ //数组仅有三个元素
    if(A[x1 = lo] < A[x2 = lo+1]) swap(x1,x2);
    if(A[x2]<A[lo+2])
      if(A[x1]<A[x2=lo+2])
        swap(x1,x2);
    return
  }
  int mi =(lo+hi)/2; //divide
  int x1L,x2L; max2(A,lo,mi,x1L,x2L);
  int x1R,X2R; max2(A,mi,hi,x1R,x2R);
  if(A[x1L] > A[x1R]){
    x1=x1L;x2=(A[x2L] > A[x1R]) ? x2L:x1R;
  }
  else{
    x1=x1R; x2 = (A[x1L] > A[x2R]) ? x1L:x2R;
  }
}
```

该思路的比较次数可通过递推方程求解:
T(n) = 2*T(n/2)+2 <= 5n/3-2
