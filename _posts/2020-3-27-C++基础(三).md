---
layout: post
title: C++基础知识(三)
description: 为学习清华大学数据机构,恶补C++语法.jpg
tag: 编程语言
---

## 第四章

### 表达式基础
C++定义了一元运算符(作用于一个运算对象)和二元运算符(作用于两个运算对象)

C++定义了运算符作用于内置类型和复合类型的运算对象时所执行的操作,当运算符作用于类
类型的运算对象时,用户可以自行定义其含义,这项操作被称为重载运算符.

我们使用重载运算符时,其包括运算对象和类型和返回值的类型,都是由该运算符定义的;
但是运算对象的个数、运算符的优先级和结合律都是无法改变的.

左值: 地址值——即存储数据值的那块内存的地址,文字常量不能被用作左值

右值: 数据值——存储在某个内存地址中;   文字常量和变量都可被用作右值

**// 左值右值理解不是很深刻**

关于求值顺序:有四种运算符明确规定了运算对象的求值顺序[逻辑与/逻辑或/条件运算符/逗号运算符]

### 算术运算符

对大多数运算符来说,布尔类型的运算对象将被提升为int类型(0/1)

算术表达式产生未定义的结果: 一: 数学性质本身   二: 源于计算机的特点(例如计算的结果超过该类型表示的范围)

note: 整数相除的结果还是整数,参与取余运算的运算对象必须是整数类型

(-m)/n和m/(-n)都等于-(m/n),m%(-n)等于m%n,(-m)%n等于-(m%n)

### 逻辑和关系运算符

逻辑与和逻辑或运算符都是先求左侧运算对象的值再求右侧运算对象的值,当且仅当左侧运算对象无法确定
表达式的结果时才会计算右侧对象的值,这种策略称为短路求值。

关系运算符比较运算对象的大小关系并返回布尔值

### 赋值运算符
赋值运算符的左侧运算对象必须是一个可修改的左值.

赋值运算满足右结合律

赋值运算优先级较低(所以经常要与括号搭配使用)

有关复合赋值运算符  a op = b(a += b) ---->  a = a op b ;

### 递增和递减运算符

关于递增和递减运算符, 主要是要强调前置和后置
```
int i = 0, j;
j = ++i; // i = 1, j = 1
j = i++; // i = 2, j = 1

// 除非必须, 否则不用递增递减运算符的后置版本
// 因为前置版本的递增运算符避免了不必要的工作, 将值加1后直接返回改变了的运算对象
```

*在一条语句中混用解引用和递增运算符*
cout << \*iter++ << endl;

递增运算符的优先级高于解引用符 \*iter++ 等价于 \*(iter++) 即iter先前移,然后取出它指向的元素

### 成员访问运算符

成员访问运算符有点运算符和箭头运算符, 点运算符获取类对象的一个成员, 箭头运算符与点运算符有关,
ptr —> mem 等价于 (\*ptr).mem

注意解引用运算符的优先级低于点运算符

### 条件运算符
cond ? expr1 : expr2

首先求cond的值, 如果条件未真对expr1求值并返回该值, 否则对expr2求值并返回该值

还可以嵌套条件运算符:

finalgrade = (grade > 90) ? "high pass": (grade < 60) ? "fail":"pass";

### 位运算符
位运算符提供检查和设置二进制位的功能[强烈建议仅将位运算符用于处理无符号类型]

提供一个使用位运算符的小例子: 挂科1/0

移位运算符的优先级比算术运算符的优先级低,但比关系运算符、赋值运算符和条件运算符的优先级高

### sizeof运算符
sizeof运算符所得的值是一个size_t类型的常量表达式

·对引用类型执行sizeof运算得到被引用对象所占空间的大小

·对指针执行sizeof运算得到被引用对象所占空间的大小

·对数组执行sizeof运算得到整个数组所占空间的大小,等价于对数组中所有元素各执行一次sizeof运算并将所得结果求和

### 类型转换
C++语言不会直接将两个不同类型的值相加, 而是根据类型转换规则设法将运算对象的类型统一后再求值
,此类型转换是自动执行的, 无须程序员的介入, 因此被称作隐式转换.[隐式转换被设计得尽可能避免损失精度]

*算术转换*
算术转换的含义是把一种算术类型转换成另外一种算术类型, 算术转换的规则定义了一套类型转换的层次,
其中运算符的运算对象将转换成最宽的类型.

· 其中整型提升负责把小整数类型转换成较大的整数类型

· 真正要理解算术转换,还是要多实践

TODO: 待补充

*其他隐式类型转换*

除了算术转换以外还有几种隐式类型转换:

数组转换成指针: 数组自动转换成指向数组首元素的指针

转换成布尔类型: 如果指针或算术类型的值为0,转换结果是false,否则转换结果是true

转换成常量: 允许将指向非常量类型的指针转换成指向相应常量类型的指针


*显式转换*

有时我们希望显式地将对象强制转换成另外一种类型,即强制类型转换[本质上很危险]

命名的强制类型转换:
一个命名的强制类型转换具有如下形式: cast-name<type>(expression)

cast-name 包括static_cast/const_cast/reinterpret_cast

TODO: 补充这些cast-name相关

**Note**

强制类型转换干扰了正常的类型检查, 因此我们建议程序员避免使用强制类型转换

## 第五章

### 简单语句
一个表达式,末尾加上分号就变成了表达式语句. 表达式语句的作用是执行表达式并丢弃掉求值结果

最简单的语句是空语句, 空语句中只含有一个单独的分号[如果在程序的某个地方, 语法上需要一条语句但是
逻辑上不需要, 此时应该使用空语句]

使用空语句时应加上注释,增加可读性

*复合语句*

复合语句是指用花括号括起来的语句和声明的序列

### 语句作用域

可以在if、while、for等控制结构内定义变量: 定义在控制结构当中的变量只在相应语句的内部可见.

### 条件语句
```
\\ 条件语句在其他语言学习中已经很熟稔了,就直接敲代码就完事了
\\ if...else
string lettergrade;
if (grade < 60)
  lettergrade = scores[0];
else
  lettergrade = scores[(grade - 50)/10];

\\ 关于if和else匹配, 就C++而言, 它规定else与离它最近的尚未匹配的if匹配[可以利用花括号控制
执行路径解决该问题]

\\ switch统计五个元音字母在文本中出现的次数
unsigned aCnt = 0, eCnt = 0, iCnt = 0, oCnt = 0, uCnt = 0;
char ch;
while (cin << ch){
  switch(ch){
    case 'a':
      ++aCnt;
      break;
    case 'e':
      ++eCnt;
      break;
    case 'i':
      ++iCnt;
      break;
    case 'o':
      ++oCnt;
      break;
    case 'u':
      ++uCnt;
      break;
  }
}
\\ case关键字和它对应的值一起被称为case标签, case标签必须是整型常量表达式
\\ 理解程序在case标签之间的执行流程很重要,如果某个case标签匹配成功,将从该标签开始往后顺序执行所有case分支
\\ 有时候我们会故意不写break的语句,如果没写break语句,最好加一段注释说清楚程序的逻辑
\\ 如果没有任何一个case标签能匹配上switch表达式的值,程序将执行紧跟在default标签后面的语句
```

*关于switch内部的变量定义*

C++语言规定, 不允许跨过变量的初始化语句直接跳转到该变量作用域内的另一个位置; --- 即当我们
需要为某个case分支定义并初始化一个变量, 我们应该把变量定义在块内, 从而确保后面所有case标签
都在变量的作用域外.
```
case true:
{

}
```

### 迭代语句

*while语句*

    定义在while条件部分或者while循环体内的变量每次迭代都经历从创建到销毁的过程

*for语句*

    for语句头中的多重定义所有变量的基础类型必须相同

*范围for语句*
```
for (declaration: expression)
  statement
```

    C++11 新标准引入了一种更简单的for语句,这种语句可以遍历容器或其他序列的所有元素
    declaration定义一个变量, 序列中的每个元素都得能转换成该变量的类型, 确保类型相容的最简单方法是使用auto类型说明符
    在范围for语句中, 预存了end()的值, 一旦在序列中添加(删除)元素, end函数的值就可能变得无效了

*do while 语句*

    与while语句最大的差别在于在第一次判断条件前就会执行一次statement

### 跳转语句
*break语句*

break语句负责终止离它最近的while,do while, for或switch语句, 并从这些语句之后的第一条语句执行
```
string buf;
while (cin >> buf && !buf.empty()){
  switch(buf[0]){
    case '-':
      // 处理到第一个空白为止
      for (auto it = buf.begin()+1; it != buf.end(); ++it){
        if(*it == ' ')
          break; // #1,离开for循环
      }
      // break #1将控制权转移到这里
      // 剩余的'-'处理:
      break; // #2,离开switch语句
      case '+':
        // ...
  } // 结束switch
  // 结束switch: break #2将控制权转移到这里
} // 结束while

```

*continue语句*

continue语句终止最近的循环中的当前迭代并立即开始下一次的迭代

*goto语句*

// 尽量不要在程序中使用goto语句, 因为它使得程序既难理解又难修改

goto语句和控制权转向的那条带标签的语句必须位于同一个函数之内

### try语句块和异常处理

异常是指存在于运行时的反常行为[处理反常行为可能是设计所有系统最难的一部分]

异常处理机制为程序中异常检测和异常处理这两部分的协作提供支持.

*throw表达式*

程序的异常检测用throw表达式引发一个异常, throw表达式包含关键字throw和紧随其后的一个表达式

*try语句块*
```
try{
  program-statements
} catch (exception-declaration){
  handler-statements
} catch (exception-declaration){
  handler-statements
}
```

*函数在寻找处理代码的过程中退出*

当异常被抛出时, 首先搜索抛出该异常的函数. 如果没找到匹配的catch子句, 终止该函数,
并在调用该函数的函数中继续寻找. 如果还是没有找到匹配的catch子句, 这个新的函数也
被终止, 继续搜索调用它的函数. 如果最终还是没能找到任何匹配的catch子句, 程序转到
名为terminate的标准库函数.

*标准异常*
C++标准库定义了一组类, 用于报告标准库函数遇到的问题.
