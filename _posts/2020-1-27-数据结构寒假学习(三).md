---
layout: post
title: 清华大学-邓俊辉MOOC数据结构与算法学习笔记(三)
description: Nope
tag: 数据结构
---

### 01-D-6/7 封底估算及其实例

封底估算(Back-of-The-Envelope Calculation)

我们常用的大O法定性的分析了一个算法的时间复杂度

而封底估算则是用头脑去抓住问题的主要方面，尽快的得出一个问题的足够近似的估计

Eg:

n = 10^9[假定当前人口数为10亿],
我们考察对全国人口普查数据的排序

![](/images/post_image/封底估算.png)

从上图中我们可以看出硬件和软件分别对该问题排序效率改进的影响,也可以意识到算法研究对实际问题的重要性

[这里可以跑个题，刚刚在微信群里看到当前防疫有调度优化算法的需求，可见算法可以在不同时刻发挥自己特有的威力]

### 01-E-1 迭代和递归

    迭代乃人工，递归方神通
    To iterate is human, to recurse, divine

*哈哈哈哈哈哈哈，这句话真是直接戳中笑点*

  递归的价值在于，许多应用问题都可简洁而准确地描述为递归形式。

设计高效DSA思想之一: 分而治之[divide and conquer]

Eg:
问题: 计算任意n个整数的和

```
int SumI(int A[], int n){
  int sum = 0; //O(1)
  for(int i = 0; i<n; i++) //O(n)
    sum += A[i]; //O(1)
  return sum;
}
```
就该特定问题而言，T(n)=1+n+1=n+2= O(n)

我们用线性递归来理解该数组求和问题

```
int sum(int A[], int n){ //数组求和算法(线性递归版)
  if(n < 1) //平凡情况，递归基
    return 0; //直接计算(避免无限递归)
  else //一般情况
    return sum(A, n - 1) + A[n - 1]; //递归:前n-1项之和，再累计最后一个项
} //O(1)*递归深度 = O(1)*(n+1) = O(n)
```

通过这个实例来理解线性递归:算法sum()可能朝着更深一层进行自我调用，且每一递归实例对自身的调用至多一次，于是，每一层次至多只有一个实例，且它们构成一个线性的次序关系。

*递归基*:将一个规模为n的大问题退化为一个规模为n-1的小问题，直至退化为规模为1的平凡情况，该平凡情况即为递归基.(base case of recursion)

### 01-E-2 减而治之
Decrease-and-conquer

![](/images/post_image/减而治之.png)

为求解一个大规模的问题，可以将其划分为两个子问题:

其一平凡;另一规模缩减，最后将缩减为一平凡的问题

### 01-E-3 递归跟踪 递推方程

**递归跟踪(recursion trace)**，具体而言，就是按照以下原则，将递归算法的执行过程整理为图的形式;

整理成图的形式所遵循的法则:
a. 算法的每一递归实例都表示为一个方框，其中注明了该实例调用的参数.

b. 若实例M调用实例N，则在M与N对应的方框之间添加一条有向联线.

![](/images/post_image/递归调用.png)

注: 向下的箭头表示递归调用，返回的箭头即表示返回值

我们从递归跟踪的角度来分析上述递归问题的时间复杂度:
从图中可以看出，该问题所需的计算时间=所有递归实例的创建、执行和销毁所需的时间总和，由于递归实例的创建和销毁均由操作系统负责完成，其对应的时间成本通常可近似为常数，如此而来，我们只需计算各递归实例中非递归调用部分所需的时间.

就上述具体问题而言，每一递归实例中需考虑 *判断n是否为0* , *累加* , *返回值* 三个元素，且每个递归实例中该三项元素至多执行一次。对于长度为n的数组，递归深度应为(n+1)

则整个算法时间复杂度T(n)=(n+1) * O(3) = O(n)

**递归方程**: 与递归跟踪分析相反，该方法无需给出具体的调用过程，而是通过对递归模式的数学归纳，导出复杂度定界函数的递推方程及其边界条件，从而将复杂度的分析，转化为递归方程的求解。

Eg: 以线性递归版sum()算法为例，将该算法处理长度为n的数组所需的时间成本记作T(n): 则为解决问题sum(A,n).需递归地解决问题sum(A,n-1),然后累加上A[n-1]

则用算式可以表示为: T(n) = T(n-1) + O(1) = T(n-1)+c
T(0)=d,用数学方法我们可以很轻易的得到T(n)=cn+d

### 01-E-4 数组倒置

Eg: 任给数组A[0,n),将其前后颠倒
如输入A[] = {3,1,4,1,5,9,2,6}，则输出A[]={6,2,9,5,1,4,1,3}

首先我们用线性递归来解决该问题

思路: 递归的关键在于通过归纳问题缩小问题的规模，在本问题中，为得到整个数组的倒置，可以先对换其首、末元素，然后递归地倒置除去首末元素后的数组.

```
void reverse(int* A,int lo,int hi){
  if(lo < hi){
    swap(A[lo], A[hi]); //交换数组首末元素
    reverse(A, lo+1,hi_1); //递归调用reverse
  } //else隐含了两种递归基(由输入数组的奇偶性带来)
}
```
分而治之

**实现递归**: 在设计递归算法时，往往需要多个角度反复尝试，方能确定对问题的输入及其规模的最佳划分方式。有时，还可能需要从不同的角度重新定义和描述原问题，使得经分解所得的子问题与原问题具有相同的语义形式


**多向递归**: 通过不同归纳问题的方式我们可以发现递归调用可能有多重可供选择的分支。

Eg: 前述计算幂函数power(2,n) = 2^n,我们可以重新定义和表述为
![](/images/post_image/幂函数的多向递归.png)

这样即可通过反复的平方运算和加倍运算得到power2(n)

代码实现:
```
__int64 power2(int n){ //优化递归版幂函数2^n算法
  if(n == 0) return 1;
  return (n & 1) ? sqr(power2(n >> 1)) << 1 : sqr(power2(n >> 1)); //根据奇偶性从二进制层面进行操作,老师真厉害.jpg
}
```

多向递归的思想也可以通过图片的形式形象的表达出来:
![](/images/post_image/分而治之.png)
