---
layout: post
title: 清华大学-邓俊辉MOOC数据结构与算法学习笔记(一)
description: 在家无聊，慕名而来，努力输出，找找事做
tag: 数据结构
---


### 01-A-1 计算

    computer science should be called computing science -E. Dijkstra

通过深入思考与分析获得对问题本质的透彻理解，按照长期积淀而成的框架与模式设计出合乎
问题内在规律的算法，选用、改进或定制足以支撑算法高效实现的数据结构，并在真实的应用
环境中充分测试、调校和改进，构成了应用计算机高效求解实现实际问题的典型流程和不二法门。

计算机科学就是研究计算的过程和规律，实现高效、有效、低耗的计算

计算的过程可以抽象理解为一种信息处理的过程。

    借助某种工具，遵照一定规则，以明确而机械的形式进行

所谓算法，即特定计算模型下，旨在解决特定问题的指令序列

    输入   待处理的信息(问题)
    输出   经处理的信息(答案)
    正确性 的确可以解决制定的问题
    确定性 任一算法都可以描述为一个由基本操作组成的序列
    可行性 每一基本操作都可实现，且在常数时间内完成
    有穷性 对于任何输入，经有穷次基本操作，都可以得到输出

证明算法有穷性的一个重要技巧:

从适当的角度审视整个计算过程，并找出其所具有的某种不变性和单调性。
单调性强调问题的规模会随着算法的推进不断递减;
不变性强调发现算法推进过程中的某种特征，并且与问题最终的正确性相对应。

### 01-A-2 算法有穷性

  考察算法有穷性，研究Hailstone(n)序列

  Hailstone sequence长度现在是有穷还是无穷的仍然存在争议

  程序未必是算法，我们可以写出程序，但是我们写出的程序亦或是代码满足算法特性时才是算法

### 01-A-3 好算法

  什么是一个好算法:

    正确: 符合语法，能够编译、链接
    健壮: 能辨别不合法的输入并做适当处理，而不致非正常退出[鲁棒性]
    可读: 结构化 + 准确命名 + 注释
    效率: 速度尽可能快;存储空间尽可能少

  ALgorithms + Data Structures = Programs

  (ALgorithms + Data Structures) * Efficiency = Computation

### 01-B-1 计算模型

  高效的计算离不开高效的数据结构和高效的算法

  所以我们的问题演变为如何去度量我们的数据结构和算法？

    To measure is to know,if you can not measure it,you can not improve it -Lord Kelvin

  衡量算法是计算机科学中的一个分支——算法分析

  问题实例的规模，往往是决定计算成本的主要因素;所以在我们计算成本时，往往需要对实例进行分类

  于是我们给出对成本的定义:
  T(n) = 用算法A求解某一问题规模为n的实例(只关注最坏的情况)，所需的计算成本


### 01-B-2 图灵机

  同一问题通常有多种算法，如何评判其优劣？

a. 实验统计是最直接的算法，但由于充分性和代表性的要求导致其可行性差

    不同的算法，可能更适应于不同规模的输入;
    不同的算法，可能更适应于不同类型的输入;
    ......

b. 为给出客观的评判，需要抽象出一个理想的平台或模型

  由此引出图灵机模型(Turing Machine)

  Transition Function (q,c;d,L/R,p)

Eg:
功能   将二进制非负整数加一

算法   全'1'的后缀翻转为全'0'，原最低位的'0'或'#'翻转为'1'

实现过程见 01-B-2 11’25

### 01-B-3 RAM

  和图灵机一样，是一般计算工具的简化与抽象，使我们可以对算法的效率做出可信的比较与评判

  寄存器顺序编号，总数没有限制 R[0],R[1],R[2],R[3]......

  基本操作与微机原理中汇编指令接近

  利用RAM模型，我们可以将前述的T(n)量化为:
  T(n) = 算法为求解规模为n的问题，所需执行的基本操作次数

Eg:
功能   实现非负整数向下取整的除法

算法   反复地从R[0] = 1+c中减去R[1] = d 统计在下溢之前，所做减法的次数x

实现过程见 01-B-3 11’00计算过程与表格(挺有意思)

### 01-C-1 大O

利用大O记号达到定性和定量的平衡

    Mathematics is more in need of good notations than of new theorems - Alan Turing

好读书不求甚解，在这里‘甚解’即过于追求定量化

我们利用渐进分析: 即在问题规模足够大后，计算成本如何增长？

大O记号: T(n) = O(f(n)) 这里注意是放大，不是缩小，所以不能直接忽略小项

特别有意思的一张图:
![](/images/post_image/大O记号.png)

这里可以认为O(n)是对T(n)的长远而言的悲观估计

### 01-C-2 渐进分析: 其它记号

算法最好情况: bigΩ

算法中间情况: bigθ

![](/images/post_image/其它记号.png)

注意在分析算法时间复杂度时要注意计算问题的输入规模，对算法复杂度的界定，都是
相对于问题的输入规模而言的。

严格的说,所谓待计算问题的输入规模，应严格定义为"用以描述输入所需的空间规模"

就countOnes()和power2BF_I()两个例子而言，将输入参数n二进制展开的宽度r作为输入规模更合理
对应的，以输入参数n本身的数值作为基准而得出O(logn)和O(n)复杂度,则应分别称作伪对数和伪线性
复杂度。


O(1)
常数复杂度(这列算法的效率最高)

通常而言，由顺序和判断逻辑构成的代码段即为常数复杂度

非常数复杂度通常含循环(显式或隐式)/递归调用等语句

O(logn)
利用换底公式可以证明底对于我们的时间复杂度分析没有意义

这类算法非常有效，复杂度无限多接近于O(1)

O(n^c) 多项式复杂度

线性(Linear function) 所有O(n)类函数

### 01-C-3 复杂度总结

T(n)=a^n [exponential function]
指数复杂度

Eg: 1.0000001^n=Ω(n^1000)

这类算法的计算成本增长极快，通常被认为是不可忍受的

    从O(n^c)到O(2^n)，通常被认为是有效算法与无效算法的一个分水岭


Eg:
2-Subset

直觉算法: 逐一枚举S的每一子集，并统计其中元素的总和  2^n

2-Subset is NP-complete问题

    NP-complete问题:就目前的计算模型而言，不存在可在多项式时间内回答此问题的算法

![](/images/post_image/复杂度1.png)

![](/images/post_image/复杂度2.png)

Note； 很多时候我们更多的仅仅关注于算法的时间复杂度，而不必对空间复杂度做专门的考察

因为就渐进复杂度的意义而言，在任一算法的任何一次运行过程中所消耗的存储空间，都不会多于
其间所执行基本操作的累计次数;

即从某种意义上来说，时间复杂度本身就是空间复杂度的一个天然上界。
