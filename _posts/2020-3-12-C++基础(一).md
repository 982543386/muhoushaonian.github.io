---
layout: post
title: C++基础知识(一)
description: 为学习清华大学数据机构,恶补C++语法.jpg
tag: 编程语言
---

## 第一章
### 1.1. 编写一个简单的C++程序

类型是程序设计最基本的概念之一,一种类型不仅定义了数据元素的内容,还定义了这类数据上可以进行的运算.

'.\' 表示该文件在当前目录中

### 1.2. 初识输入输出

C++中并未定义任何输入输出语句，而是用一个全面的标准库iostream来提供IO机制

*标准输入输出对象*

cin: 标准输入 | cout: 标准输出 | cerr: 标准错误 | clog: 程序运行时的一般性信息

```
# include<iostream>   // 告诉编译器我们想要使用iostream库

int main()
{
  // <<为输出运算符，其左侧的运算对象必须是一个ostream对象,右侧的运算对象是要打印的值
  // 在第一行代码中使用两个输出运算符: 第一个是将双引号之间的文本打印到标准输出
  // 第二个运算打印endl,写入endl的效果是结束当前行[就像C++里面的/n]
  // 此处值得注意是endl还负责与设备关联的缓冲区(buffer)中的内容刷到设备中
  // std::前缀指出名字cout和endl是在名为std的命名空间中的,标准库定义的所有名字都在命名空间std中
  // 注意""表示""里面是字符串
	std::cout << "Enter two numbers:" << std::endl;
  // 初始化保存变量,初始化一般包括变量类型和初始值(初始值的设定分为显式设定和隐式设定)
	int v1 = 0, v2 = 0;
  // 输入运算符(>>)接受一个istream作为其左侧运算对象,接受一个对象作为其右侧运算对象
  // 它将从给定的istream读入数据,并存入给定对象中
	std::cin >> v1 >>v2;
	std::cout << "The sum of " << v1 << " and " << v2
			  << " is " << v1 + v2 << std::endl;
	return 0;
 }

```

本节练习1.5还挺好玩,可以试着魔改一下std::endl [可惜的是我还是没体会到缓冲区]

### 1.3 注释简介

修改代码时，不要忘记更新注释

注释类型:
```
/*
* hello, 我是界定符对注释
* 我不能嵌套使用
*/

// hello,我是单行注释
```

### 控制流

while语句 / for语句 / if语句

*读取数量不定的输入数据*
```
#include <iostream>
int main(){
  int sum = 0,value = 0;
  // 本例中我们是以std::cin为检测条件,核心在于检测流的状态,如果状态有效,则检测成功
  // 状态无效信号: 文件结束符 / 无效输入
  while(std::cin >> value)
    sum += value;
  std::cout << "Sum is: " << sum << std::endl;
}
```

    我们要牢记一件重要的事情: 其他可能的程序格式总是存在的;当你要选择一种格式风格时,
    思考一下它会对程序的可读性和易理解性有什么影响,而一旦选择了一种风格,就要坚持使用

### 类简介

在C++中,我们通过定义一个类来定义自己的数据结构,我们需要使用头文件来访问为自己的应用程序
所定义的类.[习惯上,头文件根据其中定义的类的名字来命名]

文件重定向: 允许我们将标准输入与标准输出与命名文件关联起来
```
addItems <infile>outfile
// addItem为已编译好的可执行文件,该命令会从一个名为infile的文件读取销售记录,并将输出结果
// 写入到一个名为outfile的文件中,两文件都在当前目录下
```

## 第二章

C++基本内置类型: 算术类型 + 空类型(void)[用于特殊场合,例如当函数不返回任何值时使用空类型]

### 算术类型
为什么需要定义算术类型?

为了赋予内存中某个地址明确的含义,必须首先知道存储在该地址的数据类型.
类型决定了数据所占的比特数以及该如何解释这些比特的内容.

如何选择算术类型?

1.明确知晓数值不可能为负的时候,选用无符号类型
2.使用int执行整数运算,(如果你的数值超过了int的表示范围,选用long long
3.类型char在一些机器上是有符号的,而在另一些机器上又是无符号的.如果你需要使用
一个不大的整数,那么明确指定它的类型是signed char还是unsigned char
4.执行浮点数运算选用double,因为float通常精度不够而且双精度浮点数和单精度浮点数的
计算代价相差无几.

类型转换

高精度类型数据 ——> 低精度类型  :  截断

值得注意的是切勿混用待符号类型和无符号类型

### 字面值常量

刑如42的值被称作字面值常量,每个字面值常量对应一种数据类型

由单引号括起来的一个字符称为char型字面值['a']
双引号括起来的零个或多个字符则构成字符串型字面值["Hello World"]

字符串字面值的类型实际是数组,另外编译器在每个字符串的结尾处添加一个空字符

当然,对于字面值常量,我们可以通过添加前后缀来制定字面值的类型

### 变量
变量提供一个具名的、可供程序操作的存储空间.

对C++来说,"变量"和"对象"一般可以互换使用

注意区分变量初始化和变量赋值:初始化不是赋值,初始化的含义是创建变量时赋予其一个初始值,
而赋值的含义是把对象的当前值擦除,而以一个新值来替代.

C++初始化的不同形式:
```
int units_sold = 0;
int units_sold = {0};
int units_sold{0};
int units_sold(0);
```

花括号初始化的形式被称为 **列表初始化**,它的优势在于如果我们使用列表初始且初始值存在
丢失信息的风险,则编译器将报错.

如果未显式初始化,则变量被默认初始化:定义于任何函数体之外的变量被初始化为0,而定义在函数
体内部的内置类型变量不被初始化.[但仍然建议定义变量时就将其初始化]

### 变量声明与定义
为了允许把程序拆分成多个逻辑部分来编写,C++语言支持分离式编译(separate compilation)机制

为了支持分离式编译,C++将声明和定义区分开来,声明使得名字为程序所知,定义负责创建与名字相关的实体

声明变量也规定变量的类型和名字,但定义还申请存储空间,也会赋值.

```
extern int i; // 声明i而非定义i
extern double pi = 3.1416; // 定义
int j;        // 声明并非定义j
// 值得强调的是变量能且只能被定义一次,但可以被多次声明
```

### 标识符
C++标识符由字母、数字和下划线组成,必须以字母或下划线开头,大小字母敏感.

变量命名规范:
    ·标识符要能体现实际含义
    ·变量名一般用小写字母
    ·用户自定义的类名一般以大写字母开头
    ·如果标识符由多个单词组成,则单词间应用下划线区分

### 作用域
C++中以花括号分隔作用域

全局作用域: 全局作用域内的名字在整个程序的范围内都可使用

块作用域: 在本作用域内使用

嵌套作用域: 作用域中一旦声明了某个名字,它所嵌套着的所有作用域中都能访问该名字.同时,
允许在内层作用域中重新定义外层作用域已有的名字

### 复合类型

*引用*
[C++11中新增一种引用: 右值引用,此处暂不讨论,所以接下来的讨论默认为左值讨论]

引用实际上是为一个已经存在的对象所起的另外一个名字,定义一个引用之后,对其进行的所有操作
都是在与之绑定的对象上进行的.

注意: 引用本身不是一个对象,所以不能定义引用的引用

```
int i = 1024 , i2 =2048; // i和i2都是int
int &r = i; // r是一个引用
int &refVal4 = 10; // 错误: 引用类型的初始值必须是一个对象
int &rval3; // 错误: 引用需完成初始化
```

*指针*
指针本身是一个对象,允许对指针赋值和拷贝,存放某个对象的地址
```
int *p = &ival;
// p存放变量ival的地址,或者说p是指向变量ival的指针

```
[不能定义指向引用的指针]

指针定义与访问:
```
int *ip1, *ip2; // ip1和ip2都是指向int类型的指针
double dp,*dp2; // dp2是指向double型对象的指针,dp是double型对象

int ival = 42;
int *p = &ival;
cout << *p;  // 由符号*得到指针p所指的对象,输出42
*p = 0;             // 通过指针为变量赋值
```

除某些特殊情况,其他所有指针的类型都要和它所指向的对象严格匹配

指针值可能存在4种状态:
1.指向一个对象[即指针值为该对象的地址]

2.指向紧邻对象所占空间的下一个位置

3.空指针

4.无效指针[避免对无效指针的访问]


*相关易混淆概念*:
```
int &r = i; // &紧随类型名出现,r是一个引用
int *p;     // *紧随类型名出现,p是一个指针
p = &i;     // &在表达式中出现,为取址符
*p = i;     // *出现在表达式中,是解引用符
// p为指针,*p为指针所对应的对象
```

*空指针*
初始化空指针的几种方法:
```
int *p1 = nullptr;     // 等价于int *p1 = 0;
int *p2 = 0;
//引入库cstdlib后,可使用:
int *p3 = NULL;
```

**建议初始化所有指针,因为无效指针会让程序崩溃[并且尽可能定义对象之后再定义指向它的指针]**

*其它指针操作*
只要指针拥有一个合法值,就能作为条件:[空指针为false，非空为true]

void*是种特殊的指针类型,可用于存放任意类型对象的地址,值得注意的是我们无法直接操作void*
指针所指向的对象,因为我们并不知道这个对象到底是什么类型

*理解复合类型的声明*
注意<\*p>并不是一个完整的变量,\*是声明符

对于复合指针(即指向指针的指针),我们通过*的个数来区分指针的级别
```
int ival = 1024;
int *p1 = &ival;
int **ppi = &p1; //指向int类型指针p1的指针ppi
```

指针不能指向引用(因为引用本身不是一个对象),但是存在对指针的引用.(因为指针是对象)
```
int i = 42;
int *p; // p是一个int类型的指针
int *&r = p; //r是一个对指针p的引用

r = &i; // 即将p指向i
// 对于复杂复合类型,可以从右向左阅读其定义
```

### const限定符
*初始化和const*
当我们存在对"缓冲区大小"和"不能轻易被改变"的变量的需求时,我们就引入了const限定符
```
const int bufSize = 512;
// 接下来任何对bufSize赋值的操作都会引发错误
// const修饰的变量一定要被初始化

extern const int bufSize;
// 只在一个文件中定义bufSize,而在多个文件中使用它

//一种值得注意的情况:此时打印出来ci的值仍然为20,也就是拷贝仅仅是拷贝值而不是完成绑定关系
int val=20;
const int ci = val;
val = 10;
std::cout << ci << std::endl;
```

*const的引用*
对const的引用实际上就是对常量的引用
```
const int ci = 1024;
const int &ri = ci; //True
int &ri = ci; //False
```

*指针和const*
要想存放常量对象的地址,只能使用指向常量的指针.

指向常量的指针没有规定所指的对象必须是一个常量,所谓指向常量的指针仅仅要求不能通过
该指针改变对象的值.

*常量指针与指针常量*
指针是对象,所以C++允许把指针本身定为常量;
常量指针必须被初始化
```
int a = 1;
const int b = 2;
const int *ptr1 = &a;
int* const ptr2 = &a;
// *ptr1 = 3;  错误,间接引用常量指针不可修改内存中的数据
// *ptr2 = 4;  正确
// ptr1 = &b;  正确,常量指针可以指向其他变量
// ptr2 = &b;  错误,指针常量不可以指向其他变量
```

*顶层const*
用顶层const(top-level const)表示指针本身是个常量;而用名词底层const(low-level const)
表示指针所指的对象是一个常量.

*constexpr和常量表达式*


### 处理类型

*类型别名*
类型别名(type alias)是一个名字,它让复杂的类型名字变得简单明了、易于理解和使用

类型别名的定义方法:
```
typedef double wages;  //wages是double的同义词
wages hourly;          //等价 double hourly;
using SI = Sales_item; //SI是Sales_item的同义词
SI item                //等价Sales_item item
```

*指针、常量和类型别名*
当类型别名指代的是复合类型或常量时,就需要特别注意一点:
```
typedef char *pstring;
const pstring cstr = 0 ; // cstr是指向char的常量指针
const pstring *ps      ; // ps是指针,对象为指向char类型的指针
```

*auto类型说明符*
auto类型说明符是C++11新标准中引入的,为什么要引入呢？

因为我们在编程时需要把表达式的值赋给变量,这就要求在声明变量的时候清楚地知道表达式的类型

auto让编译器通过初始值来推算变量的类型:
```
auto item = val1 + val2; //item初始化为val1和val2相加的结果
auto i = 0, *p = &i;     //auto可以在一条语句中声明多个变量,但数据类型要相同
```

复合类型、常量和auto:
TODO: 待补充

*decltype类型指示符*
有时候我们需要从表达式的类型推断出要定义的变量类型,但是不想用该表达式的值初始化变量,
这时候就需要引入decltype.

```
decltype(f()) sum = x; // sum的类型是函数f的返回类型,f()并不被实际调用

const int ci = 0, &cj = ci;
decltype(ci) x = 0;    // x的类型是const int
decltype(cj) y = x;    // y的类型是const int&

//Note: decltype((variable))的结果永远是引用
```
TODO: 练习题

### 自定义数据结构
C++语言允许用户以类的形式自定义数据类型

类体右侧的表示结束的花括号后必须写一个分号

C++新标准规定,可以为数据成员提供一个类内初始值,没有初始值的成员将被默认初始化

*编写自己的头文件*
如果要在不同的文件中使用同一个类,类的定义就必须保持一致.

为了确保各个文件中类的定义一致,类通常被定义在头文件中,而且类所在头文件的名字应与类的名字一样.

*Note*:
头文件一旦改变,相关的源文件必须重新编译以获取更新过的声明

*预处理器概述*
确保头文件多次包含仍能安全工作的常用技术是预处理器,预处理器是在编译之前执行的一段程序

之前已经用到了一项预处理功能#include,当预处理器看到#include标记时就会用指定的头文件内容代替#include

C++程序还会用到的预处理功能是头文件保护符,头文件保护符依赖于预处理变量

*预处理变量的名字在程序中唯一，任何与预处理器变量相匹配的名字的使用都关联到该预处理器变量*

\#define 指示接受一个名字并定义该名字为预处理器变量

\#ifndef : if not define[如果没有定义指示检测指定的预处理器变量是否未定义，如果预处理器变量
未定义,那么跟在其后的所有指示都被处理,直到出现#endif]

用到预处理器变量的场景:
假设现在有头文件 xx1.h xx2.h, 其中xx1.h中包含一个类class1的定义,如果在头文件xx2.h中要用到class1
这个类,那么在xx2.h中必然要写上 #include "xx1.h"

但在主程序中,需要有 #include "xx1.h"  #include "xx2.h",这样的话xx1.h实际上被包含了两次,编译时会
出现错误,解决这个问题,我们只需要在 xx1.h中写上:

```
#ifndef XX1
#define XX1
//
xx1.h里面原有的代码
//
endif
```

Note: 整个程序中的预处理变量包括头文件保护符必须唯一,通常的做法是基于头文件中类的
名字来构建保护符的名字,以确保其唯一性.

**头文件即使还没有被包含在其他头文件中，也应该设置保护符**
